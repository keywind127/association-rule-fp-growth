from typing import *


def get_frequent_itemset_support(frequent_itemsets_with_support : Dict[ Any, Dict[ Tuple[ Any ], int ] ],
                                 frequent_itemset               : Tuple[ Any ]) -> int:
    """Given a tuple of items, return the support count of this itemset (integer)."""
    return frequent_itemsets_with_support[frequent_itemset[-1]][frequent_itemset[:-1]]


def swap_dictionary_key_value(dictionary : dict) -> dict:
    """Given a dictionary, return a dictionary where the keys and values are swapped."""
    return {  v : k for k, v in dictionary.items()  }


def itemset_tuple_to_dict(itemset : Tuple[ Any ]) -> Dict[ Any, int ]:
    """Given a tuple of items, return a dictionary where the keys are the items and the values are their indices."""
    return {  k : v for v, k in enumerate(itemset)  }


def extract_frequent_itemsets(
        frequent_itemsets_with_support : Dict[ Any, Dict[ Tuple[ Any ], int ] ]
    ) -> Set[ Tuple[ Any ] ]:

    """Given a frequent-items dictionary generated by FP-growth, return itemsets as a set of tuples."""

    frequent_itemsets : set = set()

    for tail_item, prefix_paths in frequent_itemsets_with_support.items():
        for prefix_path, _ in prefix_paths.items():
            frequent_itemsets.add((*prefix_path, tail_item))

    return frequent_itemsets


def _mine_association_rules(association_rules              : Set[ Tuple[ FrozenSet, FrozenSet, float, int ] ], 
                            frequent_itemsets_with_support : Dict[ Any, Dict[ Tuple[ Any ], int ] ],
                            antecedent                     : Dict[ Any, int ], 
                            consequent                     : Dict[ Any, int ], 
                            min_conf_float                 : float, 
                            union_length                   : int, 
                            union_support                  : int) -> None:
    
    """This function recursively mines association rules and saves those satisfying `min_conf_float`."""
    
    #print(list(antecedent.keys()))

    #print(list(consequent.keys()))

    #print("")

    # only consider association rules where both antecedent and consequent are non-empty
    if ((antecedent.__len__()) and (consequent.__len__())):

        # antecedent itemset as (index, item) dictionary
        _antecedent : dict = swap_dictionary_key_value(antecedent)

        # antecedent itemset as tuple
        _antecedent : tuple = tuple(
            _antecedent[idx] for idx in range(union_length) 
                if (idx in _antecedent)
        )

        # antecedent itemset support count
        antecedent_support : int = get_frequent_itemset_support(
            frequent_itemsets_with_support, _antecedent
        )

        # confidence score of association rule
        confidence : float = union_support / antecedent_support

        # add to association rule if greater than confidence threshold
        if (confidence >= min_conf_float):

            association_rules.add((
                frozenset(antecedent), # antecedent 
                frozenset(consequent), # consequent
                confidence,            # confidence (float)
                union_support          # support (int)
            ))

    for item, index in list(antecedent.items()):

        # move item from antecedent to consequent
        consequent[item] = index
        del antecedent[item]

        # recursively mine association rules of frequent itemset
        _mine_association_rules(
            association_rules, 
            frequent_itemsets_with_support, 
            antecedent, 
            consequent, 
            min_conf_float, 
            union_length, 
            union_support
        )

        # move item from consequent back to antecedent
        antecedent[item] = index
        del consequent[item]


def mine_association_rules(
        frequent_itemsets_with_support : Dict[ Any, Dict[ Tuple[ Any ], int ] ],
        min_conf_float : float
    ) -> Set[ Tuple[ FrozenSet[ Any ], FrozenSet[ Any ], float, int ] ]:

    """Given a frequent-items dictionary, return all association rules satisfying `min_conf_float`."""

    # set of tuples
    frequent_itemsets : set = extract_frequent_itemsets(frequent_itemsets_with_support)

    # set of tuples {  Set[ Tuple[ FrozenSet, FrozenSet, float, int ] ]  }
    association_rules : set = set()

    # iterate through each frequent itemset
    for frequent_itemset in frequent_itemsets:

        # (item, index) dictionary {  Dict[ Any, int ]  }
        antecedent : dict = itemset_tuple_to_dict(frequent_itemset)

        # (item, index) dictionary {  Dict[ Any, int ]  }
        consequent : dict = dict()

        # support count of frequent itemset (union of antecedent and consequent)
        union_support : int = get_frequent_itemset_support(frequent_itemsets_with_support, frequent_itemset)

        # number of items in frequent itemset
        union_length = len(antecedent)

        # recursively mine association rules of frequent itemset
        _mine_association_rules(
            association_rules, 
            frequent_itemsets_with_support, 
            antecedent, 
            consequent, 
            min_conf_float, 
            union_length, 
            union_support
        )
        
    # discovered association rules
    return association_rules


if (__name__ == "__main__"):

    frequent_itemsets_with_support : dict = {
        45874: {  () : 3  }, 
        9192:  {  () : 2, (45874,) : 2  }, 
        31651: {  () : 2, (45874,) : 1, (9192,) : 1, (45874, 9192) : 1  }, 
        57515: {  () : 1, (45874,) : 1  }
    }

    min_conf_float : float = 0.5 

    association_rules : set = mine_association_rules(frequent_itemsets_with_support, min_conf_float)

    print(association_rules)