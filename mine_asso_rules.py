from typing import *


def get_frequent_itemset_support(frequent_itemsets_with_support : Dict[ FrozenSet[ str ], int ], #Dict[ Any, Dict[ Tuple[ Any ], int ] ],
                                 frequent_itemset               : Tuple[ Any ]) -> int:
    """Given a tuple of items, return the support count of this itemset (integer)."""

    #print("FI:", frequent_itemset, frequent_itemsets_with_support[frequent_itemset[-1]].get())
    #return frequent_itemsets_with_support[frequent_itemset[-1]][frequent_itemset[:-1]]
    return frequent_itemsets_with_support[frozenset(frequent_itemset)]



def swap_dictionary_key_value(dictionary : dict) -> dict:
    """Given a dictionary, return a dictionary where the keys and values are swapped."""
    return {  v : k for k, v in dictionary.items()  }



def itemset_tuple_to_dict(itemset : Tuple[ Any ]) -> Dict[ Any, int ]:
    """Given a tuple of items, return a dictionary where the keys are the items and the values are their indices."""
    return {  k : v for v, k in enumerate(itemset)  }



def extract_frequent_itemsets(
            frequent_itemsets_with_support : Dict[ FrozenSet[ str ], int ],#Dict[ Any, Dict[ Tuple[ Any ], int ] ]
        ) -> Set[ FrozenSet[ str ] ]:#Set[ Tuple[ Any ] ]:

    """Given a frequent-items dictionary generated by FP-growth, return itemsets as a set of tuples."""

    frequent_itemsets : set = set()

    # for tail_item, prefix_paths in frequent_itemsets_with_support.items():
    #     for prefix_path, _ in prefix_paths.items():
    #         frequent_itemsets.add((*prefix_path, tail_item))

    for frequent_itemset, _ in frequent_itemsets_with_support.items():
        frequent_itemsets.add(frequent_itemset)

    return frequent_itemsets



def _mine_association_rules(association_rules              : Set[ Tuple[ FrozenSet[ str ], FrozenSet[ str ], float, int ] ], 
                            frequent_itemsets_with_support : Dict[ FrozenSet[ str ], int ], #Dict[ Any, Dict[ Tuple[ Any ], int ] ],
                            antecedent                     : Set[ str ], #Dict[ Any, int ], 
                            consequent                     : Set[ str ], #Dict[ Any, int ], 
                            min_conf_float                 : float, 
                            union_length                   : int, 
                            union_support                  : int,
                            num_transactions               : int) -> None:
    
    """This function recursively mines association rules and saves those satisfying `min_conf_float`."""

    # only consider association rules where both antecedent and consequent are non-empty
    if ((antecedent.__len__()) and (consequent.__len__())):


        # antecedent itemset as (index, item) dictionary
        #_antecedent : dict = swap_dictionary_key_value(antecedent)

        # antecedent itemset as tuple
        # _antecedent : tuple = tuple(
        #     _antecedent[idx] for idx in range(union_length) 
        #         if (idx in _antecedent)
        # )

        # antecedent itemset support count
        antecedent_support : int = get_frequent_itemset_support(
            frequent_itemsets_with_support, antecedent #_antecedent
        )


        # confidence score of association rule
        confidence : float = union_support / antecedent_support


        # stop adding items to antecedent if confidence is already below minimum threshold
        if (confidence < min_conf_float):
            return
        
        
        # consequent itemset as (index, item) dictionary
        #_consequent : dict = swap_dictionary_key_value(consequent)

        # consequent itemset as tuple
        # _consequent : tuple = tuple(
        #     _consequent[idx] for idx in range(union_length)
        #         if (idx in _consequent)
        # )

        # consequent itemset support count
        consequent_support : int = get_frequent_itemset_support(
            frequent_itemsets_with_support, consequent #_consequent
        )

        # conseqeunt support count to consequent support ratio
        consequent_support_float : float = consequent_support / num_transactions

        
        # union support count to union support ratio
        union_support_float      : float = union_support / num_transactions


        # P(ANT + CON) / ( P(ANT) * P(CON) ) = CONF(ANT + CON) / P(CON)
        confidence_lift          : float = confidence / consequent_support_float


        # add to association rule if greater than confidence threshold
        association_rules.add((
            frozenset(antecedent), # antecedent 
            frozenset(consequent), # consequent
            union_support_float,   # support (int)
            confidence,            # confidence (float)
            confidence_lift        # lift (float)
        ))


    #for item, index in list(antecedent.items()):
    for item in antecedent.copy():

        # move item from antecedent to consequent
        #consequent[item] = index
        consequent.add(item)
        #del antecedent[item]
        antecedent.remove(item)

        # recursively mine association rules of frequent itemset
        _mine_association_rules(
            association_rules, 
            frequent_itemsets_with_support, 
            antecedent, 
            consequent, 
            min_conf_float, 
            union_length, 
            union_support,
            num_transactions
        )

        # move item from consequent back to antecedent
        #antecedent[item] = index
        antecedent.add(item)
        #del consequent[item]
        consequent.remove(item)



def mine_association_rules(
            frequent_itemsets_with_support : Dict[ FrozenSet[ str ], int ],#Dict[ Any, Dict[ Tuple[ Any ], int ] ],
            min_conf_float                 : float,
            num_transactions               : int
        ) -> Set[ Tuple[ FrozenSet[ Any ], FrozenSet[ Any ], float, int ] ]:

    """Given a frequent-items dictionary, return all association rules satisfying `min_conf_float`."""

    # set of tuples
    frequent_itemsets : set = extract_frequent_itemsets(frequent_itemsets_with_support)

    # set of tuples {  Set[ Tuple[ FrozenSet, FrozenSet, float, int ] ]  }
    association_rules : set = set()

    # iterate through each frequent itemset
    for frequent_itemset in frequent_itemsets:

        # (item, index) dictionary {  Dict[ Any, int ]  }
        #antecedent : dict = itemset_tuple_to_dict(frequent_itemset)
        antecedent : set = set(frequent_itemset)

        # (item, index) dictionary {  Dict[ Any, int ]  }
        #consequent : dict = dict()
        consequent : set = set()

        # support count of frequent itemset (union of antecedent and consequent)
        union_support : int = get_frequent_itemset_support(frequent_itemsets_with_support, frequent_itemset)

        # number of items in frequent itemset
        union_length = len(antecedent)

        # recursively mine association rules of frequent itemset
        _mine_association_rules(
            association_rules, 
            frequent_itemsets_with_support, 
            antecedent, 
            consequent, 
            min_conf_float, 
            union_length, 
            union_support,
            num_transactions
        )
        
    # discovered association rules
    return association_rules


if (__name__ == "__main__"):

    # frequent_itemsets_with_support : dict = {
    #     45874: {  () : 3  }, 
    #     9192:  {  () : 2, (45874,) : 2  }, 
    #     31651: {  () : 2, (45874,) : 1, (9192,) : 1, (45874, 9192) : 1  }, 
    #     57515: {  () : 1, (45874,) : 1  }
    # }

    frequent_itemsets_with_support = {
        frozenset({'57515'}) : 1, 
        frozenset({'45874', '57515'}) : 1, 
        frozenset({'9192'}) : 2, 
        frozenset({'9192', '45874'}) : 2, 
        frozenset({'31651'}) : 2, 
        frozenset({'45874', '31651'}) : 1, 
        frozenset({'9192', '31651'}) : 1, 
        frozenset({'9192', '45874', '31651'}) : 1, 
        frozenset({'45874'}) : 3
    }

    min_conf_float : float = 0.5 

    num_transactions : int = 4

    association_rules : set = mine_association_rules(
        frequent_itemsets_with_support, 
        min_conf_float,
        num_transactions
    )

    print(association_rules)